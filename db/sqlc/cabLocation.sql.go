// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: cabLocation.sql

package db

import (
	"context"
)

const createCabLocation = `-- name: CreateCabLocation :one
INSERT INTO "cabLocation"(
  driver,
  cell_id,
  position,
  available
)VALUES ($1,$2,point($3,$4),$5)
RETURNING id, driver, cell_id, position, available, created_at, updated_at
`

type CreateCabLocationParams struct {
	Driver    int64   `json:"driver"`
	CellID    string  `json:"cell_id"`
	Point     float64 `json:"point"`
	Point_2   float64 `json:"point_2"`
	Available bool    `json:"available"`
}

func (q *Queries) CreateCabLocation(ctx context.Context, arg CreateCabLocationParams) (CabLocation, error) {
	row := q.db.QueryRowContext(ctx, createCabLocation,
		arg.Driver,
		arg.CellID,
		arg.Point,
		arg.Point_2,
		arg.Available,
	)
	var i CabLocation
	err := row.Scan(
		&i.ID,
		&i.Driver,
		&i.CellID,
		&i.Position,
		&i.Available,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCabLocation = `-- name: GetCabLocation :one
SELECT id, driver, cell_id, position, available, created_at, updated_at FROM "cabLocation" 
WHERE driver=$1
`

func (q *Queries) GetCabLocation(ctx context.Context, driver int64) (CabLocation, error) {
	row := q.db.QueryRowContext(ctx, getCabLocation, driver)
	var i CabLocation
	err := row.Scan(
		&i.ID,
		&i.Driver,
		&i.CellID,
		&i.Position,
		&i.Available,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCabLocationForSubscription = `-- name: GetCabLocationForSubscription :many
SELECT id, driver, cell_id, position, available, created_at, updated_at FROM "cabLocation"
WHERE cell_id = $1
`

func (q *Queries) GetCabLocationForSubscription(ctx context.Context, cellID string) ([]CabLocation, error) {
	rows, err := q.db.QueryContext(ctx, getCabLocationForSubscription, cellID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CabLocation{}
	for rows.Next() {
		var i CabLocation
		if err := rows.Scan(
			&i.ID,
			&i.Driver,
			&i.CellID,
			&i.Position,
			&i.Available,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCabLocation = `-- name: ListCabLocation :many
SELECT id, driver, cell_id, position, available, created_at, updated_at FROM "cabLocation"
WHERE   ST_DWithin(point($1 ,$2)::geography,
              ST_MakePoint(long,lat),8046.72)
`

type ListCabLocationParams struct {
	Point   float64 `json:"point"`
	Point_2 float64 `json:"point_2"`
}

func (q *Queries) ListCabLocation(ctx context.Context, arg ListCabLocationParams) ([]CabLocation, error) {
	rows, err := q.db.QueryContext(ctx, listCabLocation, arg.Point, arg.Point_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CabLocation{}
	for rows.Next() {
		var i CabLocation
		if err := rows.Scan(
			&i.ID,
			&i.Driver,
			&i.CellID,
			&i.Position,
			&i.Available,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCabLocation = `-- name: UpdateCabLocation :one
UPDATE "cabLocation" 
SET position = point($2,$3)
WHERE driver = $1
RETURNING id, driver, cell_id, position, available, created_at, updated_at
`

type UpdateCabLocationParams struct {
	Driver  int64   `json:"driver"`
	Point   float64 `json:"point"`
	Point_2 float64 `json:"point_2"`
}

func (q *Queries) UpdateCabLocation(ctx context.Context, arg UpdateCabLocationParams) (CabLocation, error) {
	row := q.db.QueryRowContext(ctx, updateCabLocation, arg.Driver, arg.Point, arg.Point_2)
	var i CabLocation
	err := row.Scan(
		&i.ID,
		&i.Driver,
		&i.CellID,
		&i.Position,
		&i.Available,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
